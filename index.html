<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scram AI</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* --- LIQUID GLASS STYLES ENHANCED --- */
        
        /* 1. Liquid Background Animation: Deeper, richer colors for better contrast */
        @keyframes gradient-shift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .liquid-bg {
            /* Deeper gradient for a high-contrast, mystical feel */
            background: linear-gradient(-45deg, #0f0a28, #000018, #301070, #0f0a28);
            background-size: 400% 400%;
            animation: gradient-shift 20s ease infinite; /* Slightly slower movement */
        }

        /* 2. Core Glassmorphism Class: Stronger blur, lower opacity, improved shadow */
        .glass-container {
            backdrop-filter: blur(22px); /* Increased blur */
            -webkit-backdrop-filter: blur(22px); 
            background-color: rgba(255, 255, 255, 0.03); /* Lower opacity for ethereal look */
            border: 1px solid rgba(255, 255, 255, 0.1); /* Lighter border */
            box-shadow: 0 10px 40px 0 rgba(0, 0, 0, 0.5), /* Stronger outer shadow */
                        inset 0 0 0 1px rgba(255, 255, 255, 0.05); /* Subtle inner white highlight */
        }

        /* 3. Custom Scrollbar styles (no change needed) */
        #chat-window::-webkit-scrollbar {
            width: 8px;
        }

        #chat-window::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        #chat-window::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
        }

        #chat-window::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        /* 4. Styling for the user image preview (no change needed) */
        .user-image-preview {
            max-width: 150px;
            max-height: 150px;
            object-fit: contain;
            border-radius: 8px;
            margin-top: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* 5. Frosted Input Style: Reusable class for inputs and labels */
        .frosted-input {
            background-color: rgba(255, 255, 255, 0.15); /* Slightly higher base opacity */
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.2s ease-in-out;
        }
        .frosted-input:hover {
             background-color: rgba(255, 255, 255, 0.25);
             border-color: rgba(255, 255, 255, 0.4);
        }
        .frosted-input:focus {
             background-color: rgba(255, 255, 255, 0.25);
             box-shadow: 0 0 0 2px rgba(147, 197, 253, 0.5);
             outline: none; /* Remove default browser outline */
        }

        /* 6. AI Bubble style enhancement */
        .ai-bubble {
            background-color: rgba(255, 255, 255, 0.1); /* slightly lower opacity for AI */
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* 7. Canvas specific styles */
        #drawing-canvas {
            background-color: rgba(255, 255, 255, 0.05); /* Very light background for drawing */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            cursor: crosshair;
        }
    </style>
</head>
<body class="liquid-bg min-h-screen flex items-center justify-center p-4">

    <!-- Main Chat Container (Now Glass) -->
    <div class="w-full max-w-2xl glass-container rounded-3xl flex flex-col h-[90vh] p-0">
        
        <!-- Header -->
        <header class="p-4 bg-white/10 text-white rounded-t-3xl shadow-lg border-b border-white/10">
            <h1 class="text-2xl font-extrabold flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM7 9a1 1 0 000 2h6a1 1 0 100-2H7z" clip-rule="evenodd" />
                </svg>
                Scram GPT
            </h1>
            <p class="text-sm opacity-90">AI Assistent made for Diamond Games.</p>
        </header>

        <!-- Chat Window -->
        <div id="chat-window" class="flex-grow p-4 overflow-y-auto space-y-4">
            <!-- Initial Greeting Message (AI Bubble - Glass) -->
            <div class="flex justify-start">
                <div class="p-3 rounded-xl rounded-tl-none max-w-xs shadow-md backdrop-blur-md text-white ai-bubble">
                    Hello! I'm Scram GPT! You can chat, upload an image, or use the Draw button to sketch your query!
                </div>
            </div>
            <!-- Messages will be injected here -->
        </div>

        <!-- CANVAS AREA -->
        <div id="drawing-pad-container" class="p-4 border-t border-white/10 bg-white/5 hidden">
            <h3 class="text-white text-md font-semibold mb-2 opacity-80">Sketch Pad</h3>
            <canvas id="drawing-canvas" class="rounded-xl w-full h-48 border border-white/10"></canvas>
            <div class="flex justify-end space-x-3 mt-2">
                <button onclick="clearCanvas()" class="text-white/70 hover:text-red-400 p-2 rounded-lg transition text-sm">Clear Sketch</button>
                <button onclick="attachCanvas()" class="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-500 transition text-sm">Attach Drawing</button>
            </div>
        </div>

        <!-- Input Area (Glass) -->
        <div class="p-4 border-t border-white/10 bg-white/5 rounded-b-3xl">
            <!-- Media Preview Container (Used for both File and Canvas) -->
            <div id="image-preview-container" class="mb-2 hidden">
                <div class="flex items-center justify-between p-2 bg-white/10 rounded-xl border border-white/10 backdrop-blur-sm">
                    <div class="flex items-center">
                        <span id="preview-label" class="text-sm font-medium mr-2 text-white">Image Attached:</span>
                        <img id="image-preview" class="user-image-preview w-10 h-10" alt="Image Preview">
                    </div>
                    <button onclick="clearMedia()" class="text-white/70 hover:text-red-400 transition duration-150 p-1 rounded-full transform hover:scale-110">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                        </svg>
                    </button>
                </div>
            </div>

            <div class="flex space-x-2">
                <!-- File Input Button (Frosted Input) -->
                <label for="media-input" class="p-3 rounded-xl cursor-pointer transition duration-200 transform hover:scale-105 shadow-md flex items-center justify-center frosted-input text-white">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z" clip-rule="evenodd" />
                    </svg>
                </label>
                <input type="file" id="media-input" accept="image/*" class="hidden" onchange="handleMediaSelect(event)">
                
                <!-- NEW: Draw Button (Frosted Input) -->
                <button onclick="toggleDrawingPad()" class="p-3 rounded-xl cursor-pointer transition duration-200 transform hover:scale-105 shadow-md flex items-center justify-center frosted-input text-white">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zm-5.646 2.121a2 2 0 00-.707 3.535l3.536 3.536a2 2 0 003.535-.707l2.282-2.283a1 1 0 000-1.414l-2.828-2.828a1 1 0 00-1.414 0l-1.06 1.06a.5.5 0 01-.708 0l-1.06-1.06a2 2 0 00-2.828 0l-1.06 1.06a.5.5 0 01-.708 0L3 13.586V17h3.414l8.293-8.293a1 1 0 000-1.414l-2.828-2.828a1 1 0 00-1.414 0z" />
                    </svg>
                </button>

                <!-- Text Input (Frosted Input) -->
                <input type="text" id="user-input" placeholder="Type your message here..." class="flex-grow p-3 rounded-xl transition duration-150 backdrop-blur-sm frosted-input text-white placeholder-gray-400" onkeydown="if(event.key === 'Enter') sendMessage()">
                
                <!-- Send Button with Hover Animation -->
                <button id="send-btn" onclick="sendMessage()" class="p-3 bg-indigo-500 text-white rounded-xl hover:bg-indigo-400 transition duration-200 transform hover:scale-105 shadow-lg flex items-center justify-center disabled:opacity-50" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" />
                    </svg>
                </button>
            </div>
        </div>

    </div>

    <!-- Custom Modal (Glassy) -->
    <div id="error-modal" class="fixed inset-0 bg-black bg-opacity-70 hidden items-center justify-center z-50 transition-opacity duration-300 opacity-0">
        <div class="glass-container p-6 rounded-lg shadow-2xl max-w-sm w-full">
            <h2 id="modal-title" class="text-xl font-bold text-red-400 mb-4">Error</h2>
            <p id="modal-message" class="text-gray-200 mb-6">Something went wrong.</p>
            <button onclick="closeModal()" class="w-full bg-red-600 text-white p-2 rounded-lg hover:bg-red-500 transition duration-150 transform hover:scale-[1.01]">Close</button>
        </div>
    </div>

    <script>
        // The API Key has been updated as requested.
        const apiKey = "AIzaSyB-ZFpQ0UmN26mZrKqombVYw05jKnXVCDE"; 
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
        const chatWindow = document.getElementById('chat-window');
        const userInput = document.getElementById('user-input');
        const sendBtn = document.getElementById('send-btn');
        const mediaInput = document.getElementById('media-input');
        const imagePreviewContainer = document.getElementById('image-preview-container');
        const imagePreview = document.getElementById('image-preview');
        const previewLabel = document.getElementById('preview-label');
        const drawingPadContainer = document.getElementById('drawing-pad-container');
        
        // Canvas elements
        const canvas = document.getElementById('drawing-canvas');
        const ctx = canvas.getContext('2d');
        let isDrawing = false;
        let attachedMedia = null; // Stores { base64Data: '...', mimeType: '...' }
        let currentMediaType = null; // 'file' or 'canvas'

        // --- Canvas Drawing Logic ---

        /** Sets up canvas dimensions and drawing style. */
        function initializeCanvas() {
            // Set canvas size based on container dimensions
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.fillStyle = "rgba(0, 0, 0, 0)"; // Transparent background
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.lineWidth = 5;
            ctx.strokeStyle = '#93c5fd'; // Light indigo color for drawing
            
            // Fill with a background color (optional, but good practice)
            ctx.fillStyle = 'transparent';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Add event listeners for both mouse and touch
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);

            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Prevent scrolling
                startDrawing(e.touches[0]);
            });
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                draw(e.touches[0]);
            });
            canvas.addEventListener('touchend', stopDrawing);
        }

        /** Starts the drawing path. */
        function startDrawing(e) {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            ctx.beginPath();
            ctx.moveTo(x, y);
        }

        /** Draws the line segment. */
        function draw(e) {
            if (!isDrawing) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            ctx.lineTo(x, y);
            ctx.stroke();
        }

        /** Stops the drawing path. */
        function stopDrawing() {
            if (isDrawing) {
                isDrawing = false;
                // Check if we should enable the send button immediately after drawing stops
                checkInputState();
            }
        }
        
        /** Clears the canvas entirely. */
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // If the attached media was the canvas, clear it
            if (currentMediaType === 'canvas') {
                clearMedia();
            }
        }

        /** Converts the canvas drawing to base64 data and attaches it. */
        function attachCanvas() {
            if (!isDrawing && !isCanvasBlank(canvas)) {
                // Convert canvas to image data URL
                const dataURL = canvas.toDataURL('image/png');
                const base64Data = dataURL.split(',')[1];
                const mimeType = 'image/png';

                // Set attached media and update UI
                attachedMedia = { base64Data, mimeType };
                currentMediaType = 'canvas';

                imagePreview.src = dataURL;
                previewLabel.textContent = 'Drawing Attached:';
                imagePreviewContainer.classList.remove('hidden');

                // Hide the drawing pad
                drawingPadContainer.classList.add('hidden');
                
                // Ensure text input can still be used
                checkInputState();
            } else {
                 showModal('Empty Sketchpad', 'Please draw something before attaching the sketch.', 'info');
            }
        }

        /** Checks if the canvas is blank (all transparent). */
        function isCanvasBlank(canvas) {
            const blankCanvas = document.createElement('canvas');
            blankCanvas.width = canvas.width;
            blankCanvas.height = canvas.height;
            return canvas.toDataURL() === blankCanvas.toDataURL();
        }

        /** Toggles the visibility of the drawing pad. */
        function toggleDrawingPad() {
            const isHidden = drawingPadContainer.classList.toggle('hidden');
            if (!isHidden) {
                // When showing the canvas, ensure file input is reset/disabled for clarity
                mediaInput.value = '';
                // Since the canvas is now visible, the user must clear any existing attached file media
                if (currentMediaType === 'file') {
                    clearMedia();
                }
                // Re-initialize to ensure size is correct if viewport changed
                initializeCanvas(); 
            }
        }


        // --- UI Utility Functions ---

        /** Shows a custom modal message. */
        function showModal(title, message, type = 'error') {
            const modal = document.getElementById('error-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalMessage = document.getElementById('modal-message');

            modalTitle.textContent = title;
            modalMessage.textContent = message;

            if (type === 'error') {
                modalTitle.classList.remove('text-indigo-400');
                modalTitle.classList.add('text-red-400');
            } else {
                modalTitle.classList.remove('text-red-400');
                modalTitle.classList.add('text-indigo-400');
            }

            modal.classList.remove('hidden', 'opacity-0');
            modal.classList.add('flex');
            setTimeout(() => modal.classList.remove('opacity-0'), 10);
        }

        /** Clears attached media and updates the preview. */
        function closeModal() {
            const modal = document.getElementById('error-modal');
            modal.classList.add('opacity-0');
            setTimeout(() => modal.classList.remove('flex'), 300);
            setTimeout(() => modal.classList.add('hidden'), 300);
        }
        
        /** Enables or disables the input and send button. */
        function setInputEnabled(enabled) {
            userInput.disabled = !enabled;
            sendBtn.disabled = !enabled;
            mediaInput.disabled = !enabled;
        }

        /** Clears attached media and updates the preview. */
        function clearMedia() {
            attachedMedia = null;
            currentMediaType = null;
            mediaInput.value = '';
            imagePreviewContainer.classList.add('hidden');
            checkInputState();
        }

        /** Scrolls the chat window to the bottom. */
        function scrollToBottom() {
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        /** * Creates and appends a chat bubble. */
        function appendMessage(text, sender, media = null) {
            const isUser = sender === 'user';
            const messageDiv = document.createElement('div');
            messageDiv.className = `flex ${isUser ? 'justify-end' : 'justify-start'}`;

            const bubble = document.createElement('div');
            bubble.className = `p-3 rounded-xl max-w-xs shadow-lg ${
                isUser 
                    ? 'bg-indigo-500 text-white rounded-br-none' 
                    : 'text-white rounded-tl-none backdrop-blur-md ai-bubble'
            }`;
            bubble.style.whiteSpace = 'pre-wrap';

            if (media && media.base64Data) {
                const img = document.createElement('img');
                img.src = `data:${media.mimeType};base64,${media.base64Data}`;
                img.alt = "User provided media";
                img.className = 'user-image-preview w-full h-auto mb-2';
                bubble.appendChild(img);
            }

            // Basic Markdown rendering
            const formattedText = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            const textContent = document.createElement('p');
            textContent.innerHTML = formattedText;
            bubble.appendChild(textContent);

            messageDiv.appendChild(bubble);
            chatWindow.appendChild(messageDiv);
            scrollToBottom();
            return messageDiv;
        }

        // --- Media Handling ---

        /** Converts a File object to a Base64 string. */
        function fileToGenerativePart(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => {
                    const base64Data = reader.result.split(',')[1];
                    const mimeType = file.type;
                    resolve({ base64Data, mimeType });
                };
                reader.onerror = error => reject(error);
            });
        }

        /** Handles the file input change event. */
        async function handleMediaSelect(event) {
            const file = event.target.files[0];
            if (!file) {
                clearMedia();
                return;
            }

            if (!file.type.startsWith('image/')) {
                showModal('Unsupported File Type', 'Please upload an image file (e.g., JPEG, PNG).', 'error');
                clearMedia();
                return;
            }

            try {
                // If the drawing pad is visible, hide it
                if (!drawingPadContainer.classList.contains('hidden')) {
                    toggleDrawingPad();
                }

                // Display the image preview
                const url = URL.createObjectURL(file);
                imagePreview.src = url;
                previewLabel.textContent = 'File Attached:';
                imagePreviewContainer.classList.remove('hidden');

                // Store the base64 data for the API call
                attachedMedia = await fileToGenerativePart(file);
                currentMediaType = 'file';
                
                checkInputState();

            } catch (error) {
                console.error("Error processing media file:", error);
                showModal('Media Error', 'Could not process the image file.', 'error');
                clearMedia();
            }
        }
        
        /** Checks if the send button should be enabled. */
        function checkInputState() {
            const hasText = userInput.value.trim().length > 0;
            const hasMedia = attachedMedia !== null;
            sendBtn.disabled = !(hasText || hasMedia);
        }

        // Add event listener to input field for continuous checking
        userInput.addEventListener('input', checkInputState);
        
        // --- Chat Logic ---

        /** * Retries the fetch operation with exponential backoff. */
        async function retryWithBackoff(apiCall, retries = 5) {
            for (let i = 0; i < retries; i++) {
                try {
                    return await apiCall();
                } catch (error) {
                    if (i === retries - 1) throw error;
                    const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        /** Handles sending the message and calling the Gemini API. */
        async function sendMessage() {
            const userText = userInput.value.trim();
            const media = attachedMedia;

            if (userText === "" && media === null) {
                return;
            }

            // 1. Prepare and display user message
            appendMessage(userText, 'user', media);
            
            // 2. Clear input and media
            userInput.value = '';
            clearMedia();
            checkInputState();
            setInputEnabled(false);

            // 3. Prepare AI parts (text and image)
            let aiParts = [];
            if (userText) {
                aiParts.push({ text: userText });
            }
            if (media) {
                aiParts.push({
                    inlineData: {
                        mimeType: media.mimeType,
                        data: media.base64Data
                    }
                });
            }

            const payload = {
                contents: [{
                    parts: aiParts
                }],
            };

            // 4. Display Loading Indicator
            const loadingMessage = appendMessage('...', 'ai');

            try {
                // 5. Call Gemini API with backoff
                const response = await retryWithBackoff(async () => {
                    const res = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!res.ok) {
                        const errorBody = await res.json();
                        throw new Error(`API Error: ${res.status} - ${errorBody.error?.message || res.statusText}`);
                    }
                    return res.json();
                });

                // 6. Process the response
                const text = response.candidates?.[0]?.content?.parts?.[0]?.text;
                
                // Remove loading indicator
                loadingMessage.remove();

                if (text) {
                    appendMessage(text, 'ai');
                } else {
                    appendMessage("I received your request, but I couldn't generate a response. Please try rephrasing.", 'ai');
                }

            } catch (error) {
                console.error("Gemini API Call Failed:", error);
                
                // Remove loading indicator
                loadingMessage.remove();
                
                appendMessage("I apologize, but I encountered a network or API error while processing your request. Please try again.", 'ai');
                showModal('Communication Error', error.message, 'error');
            } finally {
                setInputEnabled(true);
            }
        }

        // --- Initialization ---
        window.onload = () => {
            initializeCanvas();
            // Initial check to disable send button if nothing is entered
            checkInputState(); 
            // Also ensure canvas size is correct on load
            window.addEventListener('resize', initializeCanvas);
        };
    </script>
</body>
</html>
